首先说明要对库有一个比较直观的理解。库是写好的现有的，成熟的，可以复用的代码。现实中每个程序都依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常。本质上说来库是一种可执行代码的二进制形式（注，其本身不可执行），可以被操作系统载入内存执行。

       静态链接库，之所以称为“静态库”，是因为在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中，因此对应的链接方式为静态链接。其实一个静态链接库可以简单看成一组目标文件(.o/.obj文件)的集合，即很多目标文件经过压缩打包后形成的一个文件。静态库特点总结：
    
              1. 静态库对函数库的链接是放在编译时期完成
    
              2. 程序在运行时对函数库再唔瓜葛，一直方便。
    
              3. 浪费空间和资源，因为所有相关的目标文件和牵涉到的函数库被链接合成一个可执行文件。
 linux下使用ar工具（windows下用lib.exe)，可以将目标文件压缩到一起，并且对其进行编号和索引，一便于查找和索引。一般创建静态链接库的步骤如下：

  动态链接库，在程序编译是并不会被连接到目标代码中，而是在程序运行时才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。动态库的一些总结：

           1. 动态库把对一些库函数的链接载入推迟到程序运行时期
    
           2. 可以实现进程之间的资源共享，（动态库也成为共享库）
    
           3. 将一些程序升级变得简单
    
           4. 设置可以真正做到链接载入完全由程序员在程序代码中控制（显式调用）


gcc/g++的编译参数，这里只介绍 -L 、-l、-include、-I、-shared、-fPIC

      -L ：表示要链接的库所在的目录。-L.  表示要链接的库在当前目录， -L/usr/lib 表示要连接的库在/usr/lib下。目录在/usr/lib时，系统会自动搜索这个目录，可以不用指明。
    
     -l (L的小写)：表示需要链接库的名称，注意不是库文件名称，比如库文件为 libtest.so，那么库名称为test
    
     -include ：包含头文件，这个很少用，因为一般情况下在源码中，都有指定头文件。
    
      -I (i 的大写)：指定头文件的所在的目录，可以使用相对路径。
    
     -shared ：指定生成动态链接库
    
     -fPIC：  表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时事通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码共享的目的。


```
g++ -E Test.cpp -o Test.i
功能：进行宏的替换，还有注释的消除，还有找到相关的库文件，生成 .i 文件。

g++ -S Test.cpp -o Test.s
功能: 生成汇编文件, .s 文件。

g++ -c Test.cpp -o Test.o #c means compile
功能: 生成目标代码（即机器码）文件，.o 文件。

g++ Test1.o Test2.o Test3.o -o Test.exe
功能：链接多个目标文件，生成可执行文件。

g++ -c main.cpp -I /usr/local -o hello.o
main.cpp文件中引用的头文件在/user/local文件夹中
```

